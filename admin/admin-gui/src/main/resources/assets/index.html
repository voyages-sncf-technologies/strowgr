<!doctype html>
<!--
  ~ Copyright (C) 2016 VSCT
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~  http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<html lang="en" ng-app="adminApp">
<head>
    <meta charset="utf-8">
    <title>Strowgr</title>

    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <link rel="stylesheet" href="webjars/angular-material/1.0.5/angular-material.min.css">
    <link rel="stylesheet" href="webjars/angular-ui-notification/0.2.0/dist/angular-ui-notification.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <script src="webjars/angularjs/1.4.9/angular.min.js"></script>

    <script src="webjars/angularjs/1.4.9/angular-route.min.js"></script>

    <script src="webjars/angularjs/1.4.9/angular-animate.min.js"></script>
    <script src="webjars/angularjs/1.4.9/angular-aria.min.js"></script>
    <script src="webjars/angularjs/1.4.9/angular-animate.min.js"></script>
    <script src="webjars/angularjs/1.4.9/angular-messages.min.js"></script>

    <script src="webjars/angular-sanitize/1.4.9/angular-sanitize.min.js"></script>

    <script src="webjars/angular-material/1.0.5/angular-material.js"></script>

    <script src="webjars/lodash/4.0.0/lodash.min.js"></script>
    <script src="webjars/angular-material-icons/0.6.0/angular-material-icons.min.js"></script>

    <script src="webjars/angular-ui-notification/0.2.0/dist/angular-ui-notification.min.js"></script>

    <style type="text/css">
        .layout-margin {
            margin: 4px;
        }

        html, body {
            height: 100%;
            margin: 0;
        }

        #wrapper {
            min-height: 100%;
        }


    </style>

    <script type="text/javascript">
        var adminApp = angular.module('adminApp', ['ngMaterial', 'ngRoute', 'ngMessages', 'ngSanitize', 'ui-notification']);
        adminApp.constant("libelle", {
            "entrypoint": "platforme",
            "un_entrypoint": "une plateforme",
            "l_entrypoint": "la plateforme"
        });
        adminApp.run(['$rootScope', 'libelle', function ($rootScope, libelle) {
            $rootScope.libelle = libelle;
        }]);

        adminApp.config(['$routeProvider', '$mdThemingProvider', 'NotificationProvider', function ($routeProvider, $mdThemingProvider, $notificationProvider) {
            $routeProvider.when('/entrypoints', {
                templateUrl: 'partials/entrypoints.html',
                controller: 'EntrypointsCtrl'
            }).when('/add-entrypoint', {
                templateUrl: 'partials/add-entrypoint.html',
                controller: 'AddEntrypointCtrl'
            }).when('/add-haproxy', {
                templateUrl: 'partials/add-haproxy.html',
                controller: 'AddHaproxyCtrl'
            }).otherwise({
                redirectTo: '/entrypoints'
            });

            $mdThemingProvider.theme('default')
                .primaryPalette('blue-grey', {
                    'default': '300',
                    'hue-1': '100',
                    'hue-2': '500',
                    'hue-3': '800'
                })
                .accentPalette('grey', {
                    'default': '300'
                })
                .warnPalette('amber');

            $notificationProvider.setOptions({
                delay: 5000,
                startTop: 20,
                startRight: 10,
                verticalSpacing: 20,
                horizontalSpacing: 20,
                positionX: 'right',
                positionY: 'bottom'
            });
        }]);

        adminApp.factory('PortProvider', ['$http', 'Notification', function ($http, Notification) {
            return {
                getPort: function (id) {
                    return $http.get('/api/ports/' + id).then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status = 404) {
                            return "Port not assigned yet";
                        } else if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                }
            }
        }]);

        adminApp.factory('Entrypoint', ['$http', 'Notification', function ($http, Notification) {
            return {
                all: function () {
                    return $http.get('/api/entrypoints/protected').then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                delete: function (id) {
                    return $http.delete('/api/entrypoints/' + escape(id)).then(function (response) {
                        Notification.success('Entrypoint ' + id + ' supprimé');
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                swapAutoreload: function (id) {
                    return $http.patch('/api/entrypoints/' + escape(id) + '/autoreload/swap').then(function (response) {
                        Notification.success('Auto reload pour ' + id);
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                isAutoreloaded: function (id) {
                    return $http.get('/api/entrypoints/' + escape(id) + '/autoreload').then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                add: function (id, conf) {
                    return $http.put('/api/entrypoints/' + id, conf).then(function (response) {
                        Notification.success('Entrypoint ' + id + ' créé');
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                update: function (id, updatableConf) {
                    return $http.patch('/api/entrypoints/' + id, updatableConf).then(function (response) {
                        Notification.success('Entrypoint ' + id + ' mis à jour');
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getCurrent: function (id) {
                    return $http.get('/api/entrypoints/' + id + '/current').then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getPending: function (id) {
                    return $http.get('/api/entrypoints/' + id + '/pending').then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getCommitting: function (id) {
                    return $http.get('/api/entrypoints/' + id + '/committing').then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                }
            }
        }]);

        adminApp.factory('Haproxy', ['$http', 'Notification', function ($http, Notification) {

            var haproxyBackendModelToFrontendModel = function (id, backendModel) {
                var hap = {
                    'id': id,
                    'name': backendModel.name,
                    'platform': backendModel.platform,
                    'autoreload': backendModel.autoreload,
                    'bindings': {}
                };
                //bindings are not stored as map but as a bunch of keys starting with 'binding/'
                for (var prop in backendModel) {
                    if (backendModel.hasOwnProperty(prop) && prop.startsWith('binding/')) {
                        var id = prop.replace('binding/', '');
                        hap['bindings'][id] = backendModel[prop];
                    }
                }
                return hap;
            };

            return {
                all: function () {
                    return $http.get('/api/haproxy/').then(function (response) {
                        return response.data.map(function (backendModelWithId) {
                            return haproxyBackendModelToFrontendModel(backendModelWithId.id, backendModelWithId);
                        });
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                get: function (id) {
                    return $http.get('/api/haproxy/' + id).then(function (response) {
                        return haproxyBackendModelToFrontendModel(id, response.data);
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                allVersions: function () {
                    return $http.get('/api/haproxy/versions').then(function (response) {
                        return response.data.sort();
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                add: function (id, conf) {
                    return $http.put('/api/haproxy/' + id, conf).then(function (response) {
                        Notification.success('Load Balancer ' + id + ' créé');
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                platforms: function () {
                    return $http.get('/api/haproxy/platforms').then(function (response) {
                        return response.data.sort();
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getBinding: function (hapid, bindingId) {
                    return $http.get('/api/haproxy/' + hapid + '/binding/' + bindingId).then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getGeneratedTemplate: function (conf) {
                    return $http({
                        method: 'POST',
                        url: '/api/haproxy/template/valorise',
                        responseType: 'text',
                        data: conf
                    }).then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getTemplate: function (uri) {
                    return $http({
                        method: 'GET',
                        url: '/api/templates?uri=' + escape(uri),
                        responseType: 'text'
                    }).then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                },
                getFrontBackends: function (uri) {
                    return $http({
                        method: 'GET',
                        url: '/api/templates/frontbackends?uri=' + escape(uri),
                        responseType: 'text'
                    }).then(function (response) {
                        return response.data;
                    }, function (error) {
                        if (error.status >= 500) {
                            Notification.error('Erreur ' + error.status + ': ' + error.message);
                        }
                        throw error;
                    });
                }
            }
        }]);

        adminApp.controller('EntrypointsCtrl', ['$scope', 'Entrypoint', '$interval', '$rootScope', '$mdDialog', function ($scope, Entrypoint, $interval, $rootScope, $mdDialog) {

            $scope.autoreloadEntrypoints = {};

            Entrypoint.all().then(function (entrypoints) {
                $scope.entrypoints = entrypoints;
                console.log('load entrypoints: ' + entrypoints);
                var size = entrypoints.length;
                for (var id = 0; id < size; id++) {
                    $scope.isAutoreloaded(entrypoints[id]);
                }
            });

            $scope.loadEntrypoint = function (id) {
                $scope.selectedEntrypoint = id;
                $rootScope.$broadcast("entrypoint-updated");
            };

            $scope.swapAutoreloadEntrypoint = function (id) {
                $scope.selectedEntrypoint = id;
                Entrypoint.swapAutoreload(id).then(function (response) {
                    $scope.isAutoreloaded(id);
                });
            };

            $scope.isAutoreloaded = function (id) {
                console.log('isAutoreloaded ? ' + id);
                Entrypoint.isAutoreloaded(id).then(function (isAutoreloaded) {
                    console.log('autoreloadEntrypoints: ' + isAutoreloaded + ' for ' + id);
                    if (isAutoreloaded) {
                        $scope.autoreloadEntrypoints[id] = 'lock_open';
                    } else {
                        $scope.autoreloadEntrypoints[id] = 'lock_outline';
                    }
                });
            };

            $scope.deleteEntrypoint = function (id, ev) {
                var confirm = $mdDialog.confirm()
                    .title('Voulez-vous supprimer cet entrypoint ?')
                    .textContent("l'entrypoint sera supprimé sur le repository et au niveau des haproxy")
                    .targetEvent(ev)
                    .ok('supprimer')
                    .cancel('annuler');
                $mdDialog.show(confirm).then(function () {
                    $scope.selectedEntrypoint = id;
                    Entrypoint.delete(id).then(function (entrypoints) {
                        $scope.entrypoints = entrypoints;
                        $rootScope.$broadcast("entrypoint-updated");
                    });
                }, function () {
                    console.log('cancel delete of ' + id);
                });
            };

        }]);

        adminApp.directive('templateDisplay', ['$mdDialog', 'Haproxy',
            function ($mdDialog, Haproxy) {
                return {
                    restrict: 'E',
                    templateUrl: 'partials/template-display.html',
                    scope: {
                        uri: '=uri'
                    },
                    link: function (scope, element, attrs) {
                        scope.showContext = function () {
                            Haproxy.getTemplate(scope.uri).then(function (value) {
                                scope.template = value;
                                $mdDialog.show({
                                    templateUrl: 'template-display/popup.html',
                                    clickOutsideToClose: true,
                                    scope: scope,
                                    autoWrap: false,
                                    openFrom: element,
                                    closeTo: element,
                                    preserveScope: true,
                                    fullscreen: false
                                });
                            }, function (error) {
                                var alert = $mdDialog.alert({
                                    htmlContent: '<pre>' + error.data.message + '</pre>',
                                    clickOutsideToClose: true,
                                    ok: "Je dois corriger la configuration"
                                });
                                $mdDialog.show(alert);
                            });
                        }
                    }
                }
            }
        ]);

        adminApp.directive('haproxyGenerated', ['$mdDialog', 'Haproxy',
            function ($mdDialog, Haproxy) {
                return {
                    restrict: 'E',
                    templateUrl: 'partials/haproxy-generated.html',
                    scope: {
                        conf: '=conf'
                    },
                    link: function (scope, element, attrs) {
                        scope.showContext = function () {
                            Haproxy.getGeneratedTemplate(scope.conf).then(function (value) {
                                scope.haproxyGenerated = value;
                                $mdDialog.show({
                                    templateUrl: 'haproxy-generated/popup.html',
                                    clickOutsideToClose: true,
                                    scope: scope,
                                    autoWrap: false,
                                    openFrom: element,
                                    closeTo: element,
                                    preserveScope: true,
                                    fullscreen: false
                                });
                            }, function (error) {
                                var alert = $mdDialog.alert({
                                    htmlContent: '<pre>' + error.data.message + '</pre>',
                                    clickOutsideToClose: true,
                                    ok: "Je dois corriger la configuration"
                                });
                                $mdDialog.show(alert);
                            });
                        }
                    }
                }
            }
        ]);

        adminApp.controller('AddEntrypointCtrl', ['$scope', 'Entrypoint', '$location', 'Haproxy', '$mdDialog', function ($scope, Entrypoint, $location, Haproxy, $mdDialog) {

            Haproxy.all().then(function (data) {
                $scope.availableHaproxies = data;
                $scope.currentHaproxy = data[0];
            });

            Haproxy.allVersions().then(function (data) {
                $scope.haproxyVersions = data;
                console.log("haproxy versions: " + data);
            });

            /* Init conf object, avoid undefined inner objects and show expected fields */
            $scope.conf = {
                haproxy: "",
                bindingId: 0,
                hapUser: "hapadm",
                context: {
                    templateUri: ""
                },
                hapVersion: "",
                frontends: [],
                backends: []
            };

            $scope.templateTypes = [
                {
                    id: 1,
                    name: "Par défaut",
                    conf: {
                        host: "gitlab.socrate.vsct.fr",
                        group: "dt",
                        repository: "haproxy-templates-horsprod",
                        tag: "1.0-DEFAULT",
                        filename: "haproxy_default_template.conf",
                        gitlabFolder: function () {
                            return "/DEFAULT";
                        }
                    }
                },
                {
                    id: 2,
                    name: "Custom",
                    conf: {
                        host: "gitlab.socrate.vsct.fr",
                        group: "dt",
                        repository: "haproxy-templates-horsprod",
                        tag: "",
                        filename: "haproxy_template.conf",
                        gitlabFolder: function () {
                            return "/" + $scope.conf.context.application;
                        }
                    }
                }
            ];

            //Make sure templateType is not null at init, even though gui part might decide to preselect an option
            $scope.templateType = $scope.templateTypes[0];

            $scope.forbiddenGlobalKeys = ['hap_user', 'syslog_port', 'application', 'platform', 'templateUri'];
            $scope.forbiddenFrontendKeys = ['id', 'port'];
            $scope.forbiddenBackendKeys = ['id'];

            $scope.currentHaproxyUpdated = function () {
                for (var i = 0; i < $scope.availableHaproxies.length; i++) {
                    var hapConf = $scope.availableHaproxies[i];
                    if (hapConf['id'] == $scope.conf.haproxy) {
                        console.log("change current haproxy to " + hapConf['id']);
                        $scope.currentHaproxy = hapConf;
                    }
                }
            };

            $scope.addFrontend = function () {
                $scope.conf.frontends.push({
                    id: "",
                    context: {}
                });
            };

            $scope.removeFrontend = function (frontend) {
                var index = $scope.conf.frontends.indexOf(frontend);
                if (index > -1) {
                    $scope.conf.frontends.splice(index, 1);
                }
            };

            $scope.addBackend = function () {
                $scope.conf.backends.push({
                    id: "",
                    servers: [],
                    context: {}
                });
            };

            $scope.removeBackend = function (backend) {
                var index = $scope.conf.backends.indexOf(backend);
                if (index > -1) {
                    $scope.conf.backends.splice(index, 1);
                }
            };

            $scope.reloadFrontBackends = function () {
                var uri = "http://" + $scope.templateType.conf.host +
                    "/" + $scope.templateType.conf.group +
                    "/" + $scope.templateType.conf.repository +
                    "/raw/" + $scope.templateType.conf.tag +
                    $scope.templateType.conf.gitlabFolder() +
                    "/" + $scope.templateType.conf.filename;

                console.log("uri : " + uri);
                Haproxy.getFrontBackends(uri)
                    .then(function (response) {
                        // update frontends
                        for (var newfrontendId = 0; newfrontendId < response["frontends"].length; newfrontendId++) {
                            var alreadyLoaded = false;
                            var newfrontend = response["frontends"][newfrontendId];
                            for (var f = 0; f < $scope.conf.frontends.length; f++) {
                                if (newfrontend == $scope.conf.frontends[f]['id']) {
                                    alreadyLoaded = true;
                                    break;
                                }
                            }
                            if (!alreadyLoaded) {
                                $scope.conf.frontends.push({
                                    id: newfrontend,
                                    context: {}
                                });
                            }
                        }
                        console.log("frontends " + JSON.stringify($scope.conf.frontends));
                        // update backends
                        for (var backendId = 0; backendId < response["backends"].length; backendId++) {
                            var alreadyLoaded = false;
                            var newbackend = response["backends"][backendId];
                            for (var f = 0; f < $scope.conf.backends.length; f++) {
                                if (newbackend == $scope.conf.backends[f]['id']) {
                                    alreadyLoaded = true;
                                    break;
                                }
                            }
                            if (!alreadyLoaded) {
                                $scope.conf.backends.push({
                                    id: newbackend,
                                    servers: [],
                                    context: {}
                                });
                            }
                        }
                    });
            };

            /* Checks the entrypoint configuration first and then creates the entrypoint */
            $scope.createEntrypoint = function () {
                //md-option seems to convert integer to strings, which causes problem, so we use parseInt
                $scope.conf.bindingId = parseInt($scope.conf.bindingId);

                /* Construction of gitlab url */
                $scope.conf.context.templateUri = "http://" + $scope.templateType.conf.host +
                    "/" + $scope.templateType.conf.group +
                    "/" + $scope.templateType.conf.repository +
                    "/raw/" + $scope.templateType.conf.tag +
                    $scope.templateType.conf.gitlabFolder() +
                    "/" + $scope.templateType.conf.filename;

                console.log($scope.conf.context.templateUri);

                /* Since ports are provided by the backend, we simulate their presence for template valorisation validation */
                var confWithFakePorts = angular.copy($scope.conf);
                confWithFakePorts.syslogPort = "00000";
                for (var i = 0; i < confWithFakePorts.frontends.length; i++) {
                    confWithFakePorts.frontends[i].port = "00000";
                }

                Haproxy.getGeneratedTemplate(confWithFakePorts).then(function (template) {
                    return Entrypoint.add($scope.conf.context.application + '/' + $scope.conf.context.platform, $scope.conf);
                }).then(function () {
                    $location.path('/');
                }, function (error) {
                    var alert = $mdDialog.alert({
                        htmlContent: '<pre>' + error.data.message + '</pre>',
                        clickOutsideToClose: true,
                        ok: "Je reprends ma configuration"
                    });
                    $mdDialog.show(alert);
                });
            };

        }]);

        adminApp.controller('AddHaproxyCtrl', ['$scope', '$location', 'Haproxy', '$mdDialog', function ($scope, $location, Haproxy, $mdDialog) {
            /* Init conf object, avoid undefined inner objects and show expected fields */
            $scope.haproxy = {
                name: "",
                bindings: {
                    0: ''
                },
                platform: "",
                autoreload: true
            };

            $scope.haproxyId = "";

            $scope.addBinding = function () {
                $scope.haproxy.bindings[Object.keys($scope.haproxy.bindings).length] = "";
            };

            $scope.createHaproxy = function () {
                console.log("create haproxy " + $scope.haproxyId + ": " + JSON.stringify($scope.haproxy));
                Haproxy.add($scope.haproxyId, $scope.haproxy).then(function () {
                    $location.path('/');
                });
            };

            Haproxy.all().then(function (data) {
                $scope.availableHaproxies = data;
                console.log(data);
            });


            Haproxy.platforms().then(function (data) {
                $scope.platforms = data;
                console.log(data);
            });

            
            $scope.loadHaproxy = function () {
                if ($scope.haproxyId != "") {
                    console.log("load existing haproxy " + $scope.haproxyId + ": " + JSON.stringify($scope.availableHaproxies));

                    for (var currentHaproxy = 0; currentHaproxy < $scope.availableHaproxies.length; currentHaproxy++) {
                        if ($scope.availableHaproxies[currentHaproxy]["id"] == $scope.haproxyId) {
                            $scope.haproxy.name = $scope.availableHaproxies[currentHaproxy]["name"];
                            $scope.haproxy.bindings = $scope.availableHaproxies[currentHaproxy]["bindings"];
                            //This line helps migration of existing haproxy conf without bindings by creating a default one if empty
                            if (Object.keys($scope.haproxy.bindings).length == 0) {
                                $scope.haproxy.bindings = {0: ''};
                            }
                            $scope.haproxy.platform = $scope.availableHaproxies[currentHaproxy]["platform"];
                            $scope.haproxy.autoreload = ("true" == $scope.availableHaproxies[currentHaproxy]["autoreload"]);
                            console.log("load haproxy " + JSON.stringify($scope.availableHaproxies[currentHaproxy]));
                        }
                    }
                }
            }

        }]);

        adminApp.directive('entrypointUpdate', ['Haproxy', '$mdDialog', '$rootScope', 'Entrypoint', function (Haproxy, $mdDialog, $rootScope, Entrypoint) {
            return {
                templateUrl: 'partials/update-entrypoint.html',
                scope: {
                    conf: '=conf'
                },
                link: function (scope, element, attrs) {
                    scope.libelle = $rootScope.libelle;
                    scope.forbiddenGlobalKeys = ['hap_user', 'syslog_port', 'application', 'platform', 'templateUri'];
                    scope.forbiddenFrontendKeys = ['id', 'port'];
                    scope.forbiddenBackendKeys = ['id'];
                    scope.forbiddenServerKeys = ['id', 'hostname', 'ip', 'port'];

                    //Load haproxy properties when conf is reloaded
                    scope.$watch('conf', function (newValue, oldValue) {
                        if (newValue != undefined) {
                            Haproxy.get(scope.conf.haproxy).then(function (data) {
                                scope.currentHaproxy = data;
                            });
                        }
                    }, false);


                    Haproxy.allVersions().then(function (data) {
                        scope.haproxyVersions = data;
                        console.log("haproxy versions: " + data);
                    });

                    scope.addFrontend = function () {
                        scope.conf.frontends.push({
                            id: "",
                            context: {}
                        });
                    };

                    scope.removeFrontend = function (frontend) {
                        var index = scope.conf.frontends.indexOf(frontend);
                        if (index > -1) {
                            scope.conf.frontends.splice(index, 1);
                        }
                    };

                    scope.addBackend = function () {
                        scope.conf.backends.push({
                            id: "",
                            servers: [],
                            context: {}
                        });
                    };

                    scope.removeBackend = function (backend) {
                        var index = scope.conf.backends.indexOf(backend);
                        if (index > -1) {
                            scope.conf.backends.splice(index, 1);
                        }
                    };

                    scope.removeServer = function (backend, server) {
                        var index = backend.servers.indexOf(server);
                        if (index > -1) {
                            var removedServer = backend.servers.splice(index, 1);
                            console.log("remove server " + index + " from " + JSON.stringify(removedServer));
                        }
                    };

                    scope.reloadFrontBackends = function () {
                        console.log('reload');

                        var uri = scope.conf.context.templateUri;
                        console.log("uri : " + uri);
                        Haproxy.getFrontBackends(uri)
                            .then(function (response) {
                                // update frontends
                                for (var newfrontendId = 0; newfrontendId < response["frontends"].length; newfrontendId++) {
                                    var alreadyLoaded = false;
                                    var newfrontend = response["frontends"][newfrontendId];
                                    for (var f = 0; f < scope.conf.frontends.length; f++) {
                                        if (newfrontend == scope.conf.frontends[f]['id']) {
                                            alreadyLoaded = true;
                                            break;
                                        }
                                    }
                                    if (!alreadyLoaded) {
                                        scope.conf.frontends.push({
                                            id: newfrontend,
                                            context: {}
                                        });
                                    }
                                }
                                console.log("frontends " + JSON.stringify(scope.conf.frontends));
                                // update backends
                                for (var backendId = 0; backendId < response["backends"].length; backendId++) {
                                    var alreadyLoaded = false;
                                    var newbackend = response["backends"][backendId];
                                    for (var f = 0; f < scope.conf.backends.length; f++) {
                                        if (newbackend == scope.conf.backends[f]['id']) {
                                            alreadyLoaded = true;
                                            break;
                                        }
                                    }
                                    if (!alreadyLoaded) {
                                        scope.conf.backends.push({
                                            id: newbackend,
                                            context: {}
                                        });
                                    }
                                }
                            });

                    }


                    scope.updateEntrypoint = function () {
                        console.log("update entrypoint")
                        //Create the update model
                        var frontends = [];
                        for (var i = 0; i < scope.conf.frontends.length; i++) {
                            var f = scope.conf.frontends[i];
                            frontends.push({
                                id: f.id,
                                context: f.context
                            })
                        }

                        var backends = [];
                        for (var i = 0; i < scope.conf.backends.length; i++) {
                            var b = scope.conf.backends[i];
                            var servers = [];
                            for (var j = 0; j < b.servers.length; j++) {
                                servers.push({
                                    id: b.servers[j].id,
                                    contextOverride: b.servers[j].contextOverride
                                });
                            }
                            console.log("push new servers:"+JSON.stringify(servers));
                            backends.push({
                                id: b.id,
                                context: b.context,
                                servers: servers
                            })
                        }

                        var updateModel = {
                            hapUser: scope.conf.hapUser,
                            //md-option seems to convert integer to strings, which causes problem, so we use parseInt
                            bindingId: parseInt(scope.conf.bindingId),
                            hapVersion: scope.conf.hapVersion,
                            context: scope.conf.context,
                            frontends: frontends,
                            backends: backends
                        };

                        /* Since ports are provided by the backend, we simulate their presence for new frontends for template valorisation validation */
                        var confWithFakePorts = angular.copy(scope.conf);
                        for (var i = 0; i < confWithFakePorts.frontends.length; i++) {
                            if (confWithFakePorts.frontends[i].port == undefined) {
                                confWithFakePorts.frontends[i].port = "00000";
                            }
                        }
                        ;

                        Haproxy.getGeneratedTemplate(confWithFakePorts).then(function (response) {
                            return Entrypoint.update(scope.conf.context.application + '/' + scope.conf.context.platform, updateModel);
                        }).then(function (response) {
                            $rootScope.$broadcast("entrypoint-updated");
                        }, function (error) {
                            var alert = $mdDialog.alert({
                                htmlContent: '<pre>' + error.data.message + '</pre>',
                                clickOutsideToClose: true,
                                ok: "Je reprends ma configuration"
                            });
                            $mdDialog.show(alert);
                        });
                    };

                }
            }
        }]);

        adminApp.directive('entrypointConfigurationView', ['PortProvider', 'Haproxy', '$window',
            function (PortProvider, Haproxy, $window) {
                return {

                    templateUrl: 'partials/entrypoint-configuration-view.html',
                    scope: {
                        conf: '=conf'
                    },
                    link: function (scope, element, attrs) {
                        scope.$watch('conf', function (newConf, oldConf) {
                            if (newConf != undefined) {
                                Haproxy.getBinding(newConf.haproxy, newConf.bindingId).then(function (bind) {
                                    scope.haproxyBind = bind;
                                });
                            }
                        });

                        scope.openStatsPage = function (frontend) {
                            $window.open("http://" + scope.haproxyBind + ":" + frontend.port + "/stats");
                        };
                    }
                }
            }
        ]);

        adminApp.directive('contextMap', ['$mdDialog',
            function ($mdDialog) {
                return {
                    restrict: 'E',
                    templateUrl: 'partials/context-map.html',
                    scope: {
                        context: '=context',
                        title: '@',
                        tooltip: '@'
                    },
                    link: function (scope, element, attrs) {
                        scope.showContext = function () {
                            $mdDialog.show({
                                templateUrl: 'context-map/popup.html',
                                clickOutsideToClose: true,
                                scope: scope,
                                autoWrap: false,
                                openFrom: element,
                                closeTo: element,
                                preserveScope: true,
                                fullscreen: false
                            });
                        };

                        scope.contextIsNotEmpty = function () {
                            return scope.context != undefined && Object.keys(scope.context).length > 0;
                        }
                    }
                }
            }
        ]);

        adminApp.directive('contextMapInput', [
            function () {
                return {
                    restrict: 'E',
                    templateUrl: 'partials/context-map-input.html',
                    scope: {
                        context: '=context',
                        forbidden: '=?forbidden',
                        readonly: '=readonly'
                    },
                    link: function (scope, element, attrs) {

                        if (scope.forbidden == undefined) scope.forbidden = [];
                        scope.chips = [];

                        scope.$watch('context', function (newContext, oldContext) {
                            if (newContext != undefined) {
                                scope.chips = Object.keys(newContext).filter(function (key) {
                                    return scope.forbidden.indexOf(key) == -1;
                                }).sort().map(function (key) {
                                    return {key: key, value: scope.context[key]};
                                });
                            }
                        }, true);

                        var chipsToContext = function () {
                            /* keys provided by some other components should not be disturbed by thoose created by context map input
                             this is why we use angular.extend */
                            scope.context = angular.extend({}, scope.chips.reduce(function (context, chip) {
                                context[chip.key] = chip.value;
                                return context;
                            }, {}), scope.context);
                        };

                        scope.validateContextInput = function (chip) {
                            var keyValue = chip.split(":");
                            if (keyValue.length != 2) return null;
                            var key = keyValue[0];
                            var value = keyValue[1];
                            if (scope.forbidden.indexOf(key) > -1) return null;
                            if (value == '') return null;
                            return {
                                key: key,
                                value: value.trim()
                            }
                        };

                        scope.add = function (item) {
                            chipsToContext();
                        };

                        scope.remove = function (item) {
                            /* remove key from scope, because it will not be in chips anymore */
                            delete scope.context[item.key];
                        }

                    }
                }
            }
        ]);

        adminApp.directive('entrypointView', ['$interval', '$timeout', 'Entrypoint', '$q', 'PortProvider',
            function ($interval, $timeout, Entrypoint, $q, PortProvider) {
                return {
                    restrict: 'E',
                    templateUrl: 'partials/entrypoint-view.html',
                    scope: {
                        id: '=id'
                    },
                    link: function (scope, element, attrs) {
                        var reloadDelay = 3000;
                        var blinkingDelay = 3000;
                        var autoRefresh = false;
                        var blinking = false;

                        refreshAllStates = function () {
                            return $q.all({
                                current: Entrypoint.getCurrent(scope.id).then(function (conf) {
                                    return portPromises(scope.id, conf);
                                }, function (error) {
                                    //TODO Check for 404
                                    scope.current = undefined
                                }),
                                pending: Entrypoint.getPending(scope.id).then(function (conf) {
                                    return portPromises(scope.id, conf);
                                }, function (error) {
                                    //TODO Check for 404
                                    scope.pending = undefined
                                }),
                                committing: Entrypoint.getCommitting(scope.id).then(function (conf) {
                                    return portPromises(scope.id, conf);
                                }, function (error) {
                                    //TODO Check for 404
                                    scope.committing = undefined
                                })
                            }).then(function (values) {
                                scope.current = values.current;
                                scope.pending = values.pending;
                                scope.committing = values.committing;
                            });
                        };

                        var portPromises = function (id, conf) {
                            var promises = [].concat(conf.frontends.map(function (frontend) {
                                return PortProvider.getPort(id + '-' + frontend.id).then(function (port) {
                                    frontend.port = port;
                                });
                            }));
                            promises.push(PortProvider.getPort(id + '-syslog').then(function (port) {
                                conf.syslogPort = port;
                            }));
                            return $q.all(promises).then(function () {
                                return conf;
                            });
                        };


                        /* When id is changed, we must reload the data */
                        scope.$watch('id', function (newValue, oldValue) {
                            autoRefresh = false;
                            blinking = false;
                            refreshAllStates().then(function () {
                                autoRefresh = true;
                                blinking = true;
                            });
                        });

                        var refreshAuto = $interval(function () {
                            if (scope.id && autoRefresh) {
                                refreshAllStates();
                            }
                        }, reloadDelay);

                        /* Make tab blink while something is committing */
                        scope.$watch('committing', function (newValue, oldValue) {
                            if (blinking) {
                                scope.commitBlink = (newValue != undefined);
                            }
                        }, true);

                        /* Make tab blink several seconds when new pending */
                        scope.$watch('pending', function (newValue, oldValue) {
                            if (blinking) {
                                scope.pendingBlink = true;
                                $timeout(function () {
                                    scope.pendingBlink = false;
                                }, blinkingDelay);
                            }
                        }, true);

                        /* Make tab blink several seconds when new current */
                        scope.$watch('current', function (newValue, oldValue) {
                            if (blinking) {
                                scope.currentBlink = true;
                                $timeout(function () {
                                    scope.currentBlink = false;
                                }, blinkingDelay);
                            }
                        }, true);

                        scope.$on('$destroy', function () {
                            $interval.cancel(refreshAuto);
                        });

                        scope.$on("entrypoint-updated", function () {
                            scope.selectedIndex = 0;
                        });

                        scope.load_update_model = function (conf) {
                            scope.update_model = conf;
                        };
                    }
                }
            }]);


    </script>
</head>
<body>
<div id="wrapper" layout="column">
    <div style="margin-bottom: 15px">
        <md-content>
            <md-toolbar>
                <div class="md-toolbar-tools">
                    <a href="/#">
                        <h1 style="font-size: 42px">
                            <span>Strowgr</span>
                        </h1>
                    </a>
                    <span flex></span>
                    <md-button class="md-raised md-accent" ng-href="/#/add-haproxy">
                        Ajouter un haproxy
                    </md-button>
                    <md-button class="md-raised md-accent" ng-href="/#/add-entrypoint">
                        Ajouter {{libelle.un_entrypoint}}
                    </md-button>
                </div>
            </md-toolbar>
        </md-content>
    </div>
    <div ng-view layout flex>
    </div>
    <div>
        <md-content>
            <md-toolbar>
                <div class="md-toolbar-tools">
                </div>
            </md-toolbar>
        </md-content>
    </div>
</div>
</body>
</html>